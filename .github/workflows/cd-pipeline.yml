name: CD - Deploy Backend Services to AKS

on:
  workflow_dispatch:
    inputs:
      aks_cluster_name:
        description: 'Name of the AKS Cluster to deploy to'
        required: true
        default: '224917579'
      aks_resource_group:
        description: 'Resource Group of the AKS Cluster'
        required: true
        default: 'deakinuni'
      aks_acr_name:
        description: 'Name of ACR'
        required: true
        default: '224917579'
      env_name:
        description: 'Name of environment'
        required: true
        default: 'staging'  

  workflow_call:

env:
  AZURE_CONTAINER_REGISTRY: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_STAGING_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
  AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
  RESOURCE_GROUP_NAME : deakinuni
  AKS_NAME : s224917579


jobs:
  deploy_to_staging:
    runs-on: ubuntu-latest
    environment: Production
    
    outputs:
      PRODUCT_API_IP: ${{ steps.get_product_ip.outputs.external_ip }}
      ORDER_API_IP: ${{ steps.get_order_ip.outputs.external_ip }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true

      - name: Set Kubernetes context (get AKS credentials)
        run: |
          az aks get-credentials --name ${{ env.AKS_NAME }} --resource-group ${{ env.RESOURCE_GROUP_NAME }} --overwrite-existing

      - name: Create staging namespace
        env:
          ENV_NAME: ${{ inputs.env_name }}
        run: |
          kubectl create namespace "$ENV_NAME" || echo "Namespace already exists"

      - name: Deploy Backend Infrastructure (ConfigMaps)
        env:
          ENV_NAME: ${{ inputs.env_name }}
        run: |
          echo "Deploying backend infrastructure..."
          cd k8s/
          kubectl apply -f configmaps.yaml -n staging

      - name: Create Kubernetes Secret (Azure + Postgres)
        env:
          ENV_NAME: ${{ inputs.env_name }}
          STORAGE_NAME: ${{ secrets.AZURE_STORAGE_ACCOUNT_NAME }}
          STORAGE_KEY: ${{ secrets.AZURE_STORAGE_ACCOUNT_KEY }}
        run: |
          echo "Creating Kubernetes secret for Storage and DB"
          kubectl create secret generic ecomm-secrets-w08e1 \
            --from-literal=POSTGRES_USER=postgres \
            --from-literal=POSTGRES_PASSWORD=postgres \
            --from-literal=AZURE_STORAGE_ACCOUNT_NAME=$STORAGE_NAME \
            --from-literal=AZURE_STORAGE_ACCOUNT_KEY=$STORAGE_KEY \
            -n staging --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Backend Infrastructure (Databases)
        env:
          ENV_NAME: ${{ inputs.env_name }}
        run: |
          echo "Deploying backend infrastructure..."
          cd k8s/
          kubectl apply -f product-db.yaml -n staging
          kubectl apply -f order-db.yaml -n staging

      - name: Deploy Backend Microservices (Product, Order)
        env:
          ENV_NAME: ${{ inputs.env_name }}      
        run: |
          echo "Deploying backend microservices..."
          cd k8s/
          kubectl apply -f product-service.yaml -n staging
          kubectl apply -f order-service.yaml -n staging
      
      - name: Wait for Backend LoadBalancer IPs
        run: |
          echo "Waiting for Product, Order LoadBalancer IPs to be assigned (up to 5 minutes)..."
          PRODUCT_IP=""
          ORDER_IP=""
          
          for i in $(seq 1 60); do
            echo "Attempt $i/60 to get IPs..."
            PRODUCT_IP=$(kubectl get service product-service-w08e1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            ORDER_IP=$(kubectl get service order-service-w08e1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

            if [[ -n "$PRODUCT_IP" && -n "$ORDER_IP" ]]; then
              echo "All backend LoadBalancer IPs assigned!"
              echo "Product Service IP: $PRODUCT_IP"
              echo "Order Service IP: $ORDER_IP"
              break
            fi
            sleep 5 # Wait 5 seconds before next attempt
          done
          
          if [[ -z "$PRODUCT_IP" || -z "$ORDER_IP" ]]; then
            echo "Error: One or more LoadBalancer IPs not assigned after timeout."
            exit 1 # Fail the job if IPs are not obtained
          fi
          
          # These are environment variables for subsequent steps in the *same job*
          # And used to set the job outputs
          echo "PRODUCT_IP=$PRODUCT_IP" >> $GITHUB_ENV
          echo "ORDER_IP=$ORDER_IP" >> $GITHUB_ENV


      - name: Inject Backend IPs into Frontend main.js
        run: |
          echo "Injecting IPs into frontend/static/js/main.js"
          # Ensure frontend/main.js is directly in the path for sed
          sed -i "s|_PRODUCT_API_URL_|http://${{ env.PRODUCT_IP }}|g" frontend/main.js
          sed -i "s|_ORDER_API_URL_|http://${{ env.ORDER_IP }}|g" frontend/main.js

          # Display the modified file content for debugging
          echo "--- Modified main.js content ---"
          cat frontend/main.js
          echo "---------------------------------"

      # Login to Azure Container Registry (ACR)
      - name: Login to Azure Container Registry
        run: az acr login --name ${{ env.AZURE_CONTAINER_REGISTRY }}

      - name: Build and Push Frontend Image
        run: |
          docker build -t ${{ secrets.AZURE_CONTAINER_REGISTRY }}/frontend:latest ./frontend/
          docker push ${{ secrets.AZURE_CONTAINER_REGISTRY }}/frontend:latest

      - name: Deploy Frontend to AKS  
        run: |
          echo "Deploying frontend with latest tag to AKS cluster: ${{ inputs.aks_cluster_name }}"
          cd k8s/
          # Ensure frontend-service.yaml is configured with your ACR
          kubectl apply -f frontend.yaml -n staging
      
      - name: Get frontend external IP
        id: get_frontend_ip
        run: |
          FRONTEND_IP=$(kubectl get svc frontend-aks -n staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Frontend service is available at: $FRONTEND_IP"
          echo "::set-output name=frontend_ip::$FRONTEND_IP"

      - name: Display Frontend IP
        run: |
          echo "Frontend service is now available at: ${{ steps.get_frontend_ip.outputs.frontend_ip }}"

      - name: Wait for manual acceptance testing (e.g., 5 minutes)
        run: |
          echo "Staging environment is ready at http://${{ steps.get_frontend_ip.outputs.frontend_ip }}. You have 5 minutes to perform manual tests."
          sleep 60 # Wait for 1 minutes

  destroy_staging:
    runs-on: ubuntu-latest
    needs: deploy_to_staging
    if: success()
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS credentials
        run: |
          az aks get-credentials --name ${{ env.AKS_NAME }} --resource-group ${{ env.RESOURCE_GROUP_NAME }}

      - name: Delete staging namespace
        run: |
          kubectl delete namespace staging

      - name: Logout from Azure
        run: az logout
